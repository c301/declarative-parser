(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('utils',factory);
  } else {
    return root.utils = factory();
  }
})(this, function() {
  return {

    /*
    Evaluate xpath string
    @param aNode context node
    @param aExpr Xpath expression
     */
    xpathEval: function(aNode, aExpr) {
      var e, found, nsResolver, res, result, xpe;
      if (arguments.length === 1) {
        aExpr = aNode;
        aNode = document;
      }
      xpe = new XPathEvaluator();
      nsResolver = xpe.createNSResolver(aNode.ownerDocument === null ? aNode.documentElement : aNode.ownerDocument.documentElement);
      try {
        result = xpe.evaluate(aExpr, aNode, nsResolver, 0, null);
      } catch (_error) {
        e = _error;
        console.log(e);
        return false;
      }
      found = [];
      if (result.resultType === 4) {
        while (res = result.iterateNext()) {
          found.push(res);
        }
        if (found.length) {
          return found;
        } else {
          return null;
        }
      } else {
        if (result.resultType === 2) {
          return result.stringValue;
        }
      }
    },
    isEmpty: function(obj) {
      var hasOwnProperty, key;
      hasOwnProperty = Object.prototype.hasOwnProperty;
      if (obj === null) {
        return true;
      }
      if (obj.length && obj.length > 0) {
        return false;
      }
      if (obj.length === 0) {
        return true;
      }
      for (key in obj) {
        if (hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
  };
});

var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('operations',["q", "utils"], factory);
  } else {
    return root.operations = factory(root.Q, root.utils);
  }
})(this, function(Q, utils) {
  var operations;
  operations = {};
  operations.manual = function() {
    if (this.config && typeof this.config.value !== "undefined") {
      return this.config.value;
    } else {
      return null;
    }
  };
  operations.regex = function(value) {
    var applyRegex, result, toReturn;
    result = null;
    applyRegex = (function(_this) {
      return function(value) {
        var modifier, nextRes, reg, res, toReturn;
        toReturn = null;
        if (value) {
          modifier = "";
          if (typeof _this.config.modifier !== 'undefined') {
            modifier = _this.config.modifier;
          }
          reg = new RegExp(_this.config.regex, modifier);
          if (__indexOf.call(modifier, 'g') >= 0) {
            toReturn = [];
            while ((nextRes = reg.exec(value)) !== null) {
              if (nextRes) {
                if (_this.config.full) {
                  toReturn.push(nextRes);
                } else {
                  toReturn.push(nextRes[1]);
                }
              }
            }
          } else {
            res = reg.exec(value);
            if (_this.config.full) {
              if (res) {
                toReturn = res;
              } else {
                toReturn = null;
              }
            } else {
              if (res) {
                toReturn = res[1];
              } else {
                toReturn = null;
              }
            }
          }
          return toReturn;
        } else {
          return null;
        }
      };
    })(this);
    if (Array.isArray(value)) {
      return toReturn = value.map(applyRegex);
    } else {
      return applyRegex(value);
    }
  };
  operations.xpath = function(value) {
    var d, el, fname, m, parser, xpath, _i, _len;
    xpath = this.config.xpath;
    if (xpath) {
      if (this.config.document_url) {
        d = Q.defer();
        this.createOperation(this.config.document_url).evaluate().then((function(_this) {
          return function(result) {
            var xhr;
            xhr = new XMLHttpRequest();
            xhr.open('GET', result, true);
            xhr.onload = function(e) {
              var doc, el, fname, m, parser, txt, xpathResult, _i, _len;
              if (xhr.status === 200) {
                txt = xhr.responseText;
                parser = new DOMParser();
                doc = parser.parseFromString(txt, "text/html");
                m = xpath.match(/\{:(.+?):\}/ig);
                if (m) {
                  parser = _this.getParser();
                  for (_i = 0, _len = m.length; _i < _len; _i++) {
                    fname = m[_i];
                    el = /\{:(.+?):\}/.exec(fname)[1];
                    if (parser) {
                      xpath = xpath.replace(fname, parser.getAttr(el));
                    }
                  }
                }
                xpathResult = utils.xpathEval(doc, xpath);
                return d.resolve(xpathResult);
              } else {
                return d.resolve(new Error());
              }
            };
            xhr.ontimeout = function(e) {
              return d.resolve(new Error());
            };
            xhr.onerror = function(e) {
              return d.resolve(new Error());
            };
            return xhr.send();
          };
        })(this));
        return d.promise;
      } else {
        m = xpath.match(/\{:(.+?):\}/ig);
        if (m) {
          parser = this.getParser();
          for (_i = 0, _len = m.length; _i < _len; _i++) {
            fname = m[_i];
            el = /\{:(.+?):\}/.exec(fname)[1];
            if (parser) {
              xpath = xpath.replace(fname, parser.getAttr(el));
            }
          }
        }
        if (this.config.doc) {
          d = Q.defer();
          this.createOperation(this.config.doc).evaluate(value).then((function(_this) {
            return function(doc) {
              var res;
              res = utils.xpathEval(doc, xpath);
              return d.resolve(res);
            };
          })(this));
          return d.promise;
        } else {
          if (value instanceof HTMLDocument || value instanceof XMLDocument) {
            return utils.xpathEval(value, xpath);
          } else {
            return utils.xpathEval(this.getDoc(), xpath);
          }
        }
      }
    } else {
      return null;
    }
  };
  operations.wait = function(value) {
    var d;
    d = Q.defer();
    window.setTimeout(function() {
      return d.resolve(value);
    }, this.config.delay);
    return d.promise;
  };
  operations.get_attribute = function(value) {
    var d, getAttr, res;
    d = Q.defer();
    getAttr = function(el, attr) {
      var res;
      res = el[attr];
      if (!res && (el instanceof HTMLElement || el.getAttribute)) {
        return res = el.getAttribute(attr || null);
      } else {
        return res || null;
      }
    };
    if (value) {
      res = [];
      this.createOperation(this.config.attribute).evaluate().then(function(attribute) {
        var e, el, _i, _len;
        try {
          if (!value[attribute] && value.length !== void 0) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              el = value[_i];
              if (el) {
                res.push(getAttr(el, attribute));
              }
            }
          } else {
            res = getAttr(value, attribute);
          }
          return d.resolve(res);
        } catch (_error) {
          e = _error;
          console.log(e);
          return d.resolve(null);
        }
      });
    } else {
      d.resolve(value);
    }
    return d.promise;
  };
  operations.set_attribute = function(value) {
    var attr, toWait;
    attr = this.config.attribute;
    if (!(value instanceof Array)) {
      value = [value];
    }
    toWait = [];
    value.forEach((function(_this) {
      return function(el) {
        var calculateAttr, d, finalAttrs, k, v, _fn;
        d = Q.defer();
        finalAttrs = {};
        calculateAttr = [];
        _fn = function(k, v) {
          var def;
          def = _this.createOperation(v).evaluate(el).then(function(finalValue) {
            return finalAttrs[k] = finalValue;
          });
          return calculateAttr.push(def);
        };
        for (k in attr) {
          if (!__hasProp.call(attr, k)) continue;
          v = attr[k];
          _fn(k, v);
        }
        Q.allSettled(calculateAttr).then(function() {
          for (k in finalAttrs) {
            if (!__hasProp.call(finalAttrs, k)) continue;
            v = finalAttrs[k];
            el[k] = v;
          }
          return d.resolve();
        });
        return toWait.push(d.promise);
      };
    })(this));
    return Q.allSettled(toWait);
  };
  operations.switchOf = function(value) {
    var execPosOrNeg;
    execPosOrNeg = (function(_this) {
      return function(res) {
        if (!!res) {
          return _this.createOperation(_this.config.positive).evaluate(value);
        } else {
          return _this.createOperation(_this.config.negative).evaluate(value);
        }
      };
    })(this);
    if (this.config.value) {
      return this.createOperation(this.config.value).evaluate(value).then((function(_this) {
        return function(res) {
          return _this.createOperation(_this.config.flag).evaluate(res).then(function(res) {
            return execPosOrNeg(res);
          });
        };
      })(this));
    } else if (this.config.flag) {
      return this.createOperation(this.config.flag).evaluate(value).then((function(_this) {
        return function(res) {
          return execPosOrNeg(res);
        };
      })(this));
    } else {
      return execPosOrNeg(value);
    }
  };
  operations.html_template = function() {
    var fname, html, toWait, _fn, _i, _len, _ref;
    html = this.config.template;
    toWait = Q(true);
    _ref = html.match(/\{:(.+?):\}/ig);
    _fn = (function(_this) {
      return function(fname) {
        var el;
        el = /\{:(.+?):\}/.exec(fname)[1];
        return toWait = toWait.then(function(val) {
          html = html.replace(fname, val || '');
          return Q(_this.getValue(el));
        });
      };
    })(this);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      fname = _ref[_i];
      _fn(fname);
    }
    return toWait.then(function() {
      return html;
    });
  };
  operations.values_to_map = function(value) {};
  operations.current_document = function() {
    return this.getDoc();
  };
  operations.equal = function(value) {
    var res;
    res = null;
    if (this.config.is_regex) {
      res = new RegExp(this.config.value, "i").test(value);
    } else {
      res = value === this.config.value;
    }
    return res;
  };
  operations.parsed_val = function() {
    var valueName;
    valueName = this.config.valName || this.config.name;
    return Q(this.getValue(valueName)).then((function(_this) {
      return function(value) {
        if (typeof value === 'undefined') {
          console.log("Warning: " + valueName + " not found");
        }
        return value;
      };
    })(this));
  };
  operations.concatenation = function() {
    var d, glue, part, parts, toWait, _fn, _i, _len;
    parts = this.config.parts;
    glue = this.config.glue || "";
    toWait = [];
    d = Q.defer();
    _fn = (function(_this) {
      return function(part) {
        return toWait.push(_this.createOperation(part).evaluate().then(function(res) {
          return res;
        }));
      };
    })(this);
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      _fn(part);
    }
    Q.allSettled(toWait).then((function(_this) {
      return function(res) {
        var result;
        result = res.map(function(v) {
          return v.value;
        });
        result = result.filter(function(val) {
          if (val) {
            return val;
          }
        });
        result = result.join(glue);
        return d.resolve(result);
      };
    })(this));
    return d.promise;
  };
  operations.collection = function() {
    var d, part, parts, toWait, _fn, _i, _len;
    parts = this.config.parts;
    toWait = [];
    d = Q.defer();
    _fn = (function(_this) {
      return function(part) {
        return toWait.push(_this.createOperation(part).evaluate().then(function(res) {
          return res;
        }));
      };
    })(this);
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      _fn(part);
    }
    Q.allSettled(toWait).then((function(_this) {
      return function(res) {
        var result;
        result = res.map(function(v) {
          return v.value;
        });
        return d.resolve(result.filter(function(val) {
          if (val) {
            return val;
          }
        }));
      };
    })(this));
    return d.promise;
  };
  operations.parseJSON = function(value) {
    var res;
    res = {};
    return res = JSON.parse(value);
  };
  operations.parse_json = function(value) {
    var res;
    res = {};
    return res = JSON.parse(value);
  };
  operations.split = function(value) {
    if (this.config.separator) {
      return value.split(this.config.separator);
    } else {
      return value;
    }
  };
  operations.randomInt = function() {
    var from, getRandomInt, to;
    getRandomInt = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    from = this.config.from || 0;
    to = this.config.to || 100;
    return getRandomInt(from, to);
  };
  operations.badOperation = function() {
    return wrongVar;
  };
  operations.js_eval = function() {
    var d, i, js, m, promises, res, _fn, _i, _len;
    js = this.config.js;
    d = Q.defer();
    m = js.match(/\{:(.+?):\}/ig);
    if (m) {
      promises = [];
      _fn = (function(_this) {
        return function(i) {
          var el, tmp, val;
          el = /\{:(.+?):\}/.exec(i)[1];
          val = Q(_this.getValue(el));
          tmp = val.then(function(replacer) {
            if (!replacer) {
              replacer = '';
            }
            return js = js.replace(i, replacer);
          });
          return promises.push(tmp);
        };
      })(this);
      for (_i = 0, _len = m.length; _i < _len; _i++) {
        i = m[_i];
        _fn(i);
      }
      Q.allSettled(promises).then((function(_this) {
        return function() {
          var res;
          res = eval(js);
          return d.resolve(res);
        };
      })(this));
    } else {
      res = eval(js);
      d.resolve(res);
    }
    return d.promise;
  };
  operations.remove_element = function(value) {
    if (!(value instanceof Array)) {
      value = [value];
    }
    return value.forEach(function(el) {
      if (el && (el instanceof HTMLElement)) {
        return el.parentNode.removeChild(el);
      }
    });
  };
  return operations;
});

var __hasProp = {}.hasOwnProperty;

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('operation',["operations", "q", "utils"], factory);
  } else {
    return root.Operation = factory(root.operations, root.Q, root.utils);
  }
})(this, function(operations, Q, utils) {
  var Operation;
  Operation = (function() {
    function Operation(config) {
      var val;
      this.parser = null;
      this.field = null;
      this.config = config;

      /*
      We have to use this shortcut to create new operation inside existing one, in order to save execution context
       */
      this.createOperation = function(config) {
        return new Operation(config).setParser(this.getParser()).setField(this.getField());
      };
      this._evaluate = function(res) {
        return res || null;
      };
      this.evaluate = function(value, cb) {
        var d;
        d = Q.defer();
        cb = cb || function() {};
        if (typeof cb !== 'function') {
          cb = function() {};
        }
        if (typeof value === 'function' && arguments.length === 1) {
          cb = value;
          value = null;
        }
        if (this.config.final && value) {
          cb(value);
          d.resolve(value);
        } else {
          if (!this._evaluate) {
            null;
          } else {
            Q.fcall((function(_this) {
              return function() {
                return _this._evaluate(value);
              };
            })(this)).then((function(_this) {
              return function(result) {
                return Q.fcall(function() {
                  return _this.decorate(result);
                }).then(function(res) {
                  cb(res);
                  return d.resolve(res);
                }, function(error) {
                  var val;
                  val = _this.getField();
                  val = val ? val.name : "undefined";
                  console.log("Error during decoration " + val + ": " + _this.type, error.stack);
                  cb(result);
                  return d.resolve(result);
                });
              };
            })(this), (function(_this) {
              return function(error) {
                var val;
                if (error.type = "StopParsingError") {
                  return d.reject(error);
                } else {
                  val = _this.getField();
                  val = val ? val.name : "undefined";
                  console.log("Error in " + val + ": " + _this.type, error.stack);
                  cb(value);
                  return d.resolve(value);
                }
              };
            })(this));
          }
        }
        return d.promise;
      };
      this.setParser = function(parser) {
        this.parser = parser;
        return this;
      };
      this.getParser = function() {
        return this.parser;
      };
      this.setField = function(field) {
        this.field = field;
        return this;
      };
      this.getField = function() {
        return this.field;
      };
      this.getDoc = function() {
        var parser;
        parser = this.getParser();
        if (parser) {
          return parser.doc;
        } else {
          return document;
        }
      };
      this.getValue = (function(_this) {
        return function(valName, cb) {
          var dep, parent, parser, value, _i, _len;
          if (_this.getField() && _this.getField().parentFields) {
            parent = _this.getField().parentFields;
            for (_i = 0, _len = parent.length; _i < _len; _i++) {
              dep = parent[_i];
              if (dep.name === valName) {
                console.log("Warning: Cirsular dependencies while getting %s from %o", valName);
                return false;
              }
            }
          }
          parser = _this.getParser();
          if (parser) {
            value = parser.value(valName, _this, cb);
            return value;
          } else {
            return null;
          }
        };
      })(this);
      this.getType = function(config) {
        var attr, type, typeName, type_mapping;
        type = '';
        type_mapping = {
          "storedName": "stored",
          "xpath": "xpath",
          "regex": "regex",
          "valName": "parsed_val",
          "value": "manual",
          "attribute": "get_attribute",
          "template": "html_template",
          "opName": "pre_built",
          "js": "js_eval",
          "separator": "split"
        };
        if (config.type !== void 0) {
          type = config.type;
        } else {
          for (attr in type_mapping) {
            if (!__hasProp.call(type_mapping, attr)) continue;
            typeName = type_mapping[attr];
            if (typeof config[attr] !== "undefined") {
              type = typeName;
              break;
            }
          }
        }
        if (!type) {
          for (attr in config) {
            if (!__hasProp.call(config, attr)) continue;
            typeName = config[attr];
            if (typeof this.operations[attr] !== "undefined") {
              type = attr;
              break;
            }
          }
        }
        config.type = type;
        return type;
      };
      if (this.config === void 0) {
        this.config = {
          type: "manual",
          value: null
        };
      }
      if (this.config instanceof Array && this.config.length) {
        this.type = "operationQueue";
        this._evaluate = (function(_this) {
          return function(value) {
            return _this.evaluateQueue(value);
          };
        })(this);
      } else {
        if (typeof this.config === "string" || typeof this.config === "number" || this.config === true || this.config === false) {
          this.config = {
            type: "manual",
            value: this.config
          };
        }
        this.type = this.getType(this.config);
        if (!this.type || !this.operations[this.type]) {
          val = this.getField();
          val = val ? val.name : "undefined";
          if (this.type && !this.operations[this.type]) {
            console.log("Unknown operation type " + val + ":" + this.type, this.config);
          }
        } else {
          this._evaluate = this.operations[this.type];
        }
      }
    }

    return Operation;

  })();
  Operation.prototype.decorate = function(value) {
    var decoratorName, defer, found, func, toReturn, toWait, _ref;
    defer = Q.defer();
    toReturn = value;
    found = false;
    toWait = null;
    _ref = Operation.prototype.decorators;
    for (decoratorName in _ref) {
      func = _ref[decoratorName];
      if (typeof this.config[decoratorName] !== "undefined") {
        (function(_this) {
          return (function(decoratorName, func) {
            if (toWait === null) {
              return toWait = Q(func.call(_this, value)).then(function(r) {
                return value = r;
              });
            } else {
              return toWait = toWait.then(function(r) {
                return Q(func.call(_this, value)).then(function(r) {
                  return value = r;
                });
              });
            }
          });
        })(this)(decoratorName, func);
        found = true;
      }
    }
    if (!found) {
      defer.resolve(toReturn);
    } else {
      toWait.then(function() {
        return defer.resolve(value);
      });
    }
    return defer.promise;
  };
  Operation.prototype.evaluateQueue = function(value) {
    var ops, result, singleConf, _i, _len, _ref;
    ops = [];
    _ref = this.config;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      singleConf = _ref[_i];
      ops.push(this.createOperation(singleConf));
    }
    result = Q(ops.shift().evaluate(value));
    ops.forEach(function(f) {
      return result = result.then(function(val) {
        return f.evaluate(val);
      });
    });
    return result;
  };
  Operation.prototype.operations = operations;
  Operation.prototype.decorators = {
    post_processing: function(value) {
      return this.decorators.postProcessing.bind(this)(value);
    },
    postProcessing: function(value) {
      var operationConfig;
      operationConfig = this.config.postProcessing || this.config.post_processing || this.config.postprocessing;
      if (operationConfig) {
        return this.createOperation(operationConfig).evaluate(value);
      }
    },
    postprocessing: function(value) {
      return this.decorators.postProcessing.bind(this)(value);
    },
    normalize_space: function(value) {
      var val, _i, _len, _results;
      if (this.config.normalize_space) {
        if (value instanceof Array) {
          _results = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            val = value[_i];
            _results.push(val = Operation.prototype.decorators.normalize_space.bind(this)(val));
          }
          return _results;
        } else {
          if (value === void 0 || typeof value !== 'string') {
            return value;
          } else {
            value = value.trim();
            value = value.replace(/[ \t]{2,}/g, ' ');
            value = value.replace(/^\s*$[\n\r]{1,}/gm, "\n");
            return value;
          }
        }
      } else {
        return value;
      }
    },
    glue: function(value) {
      if (value instanceof Array) {
        return value.filter(function(val) {
          if (val) {
            return val;
          }
        }).join(this.config.glue);
      } else {
        return value;
      }
    },
    suffix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.suffix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(value + res);
          }
          if (value instanceof Array) {
            newvalue = value.map((function(_this) {
              return function(el) {
                if (el) {
                  return el + res;
                } else {
                  return el;
                }
              };
            })(this));
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    preffix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.preffix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(res + value);
          }
          if (value instanceof Array) {
            newvalue = value.map((function(_this) {
              return function(el) {
                if (el) {
                  return res + el;
                } else {
                  return el;
                }
              };
            })(this));
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    prefix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.prefix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(res + value);
          }
          if (value instanceof Array) {
            newvalue = value.map((function(_this) {
              return function(el) {
                if (el) {
                  return res + el;
                } else {
                  return el;
                }
              };
            })(this));
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    num_in_array: function(value) {
      if (value instanceof Array) {
        return value[this.config.num_in_array];
      } else {
        return value;
      }
    },
    "default": function(value) {
      var d;
      d = Q.defer();
      if (!value) {
        this.createOperation(this.config["default"]).evaluate().then(function(res) {
          return d.resolve(res);
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    debug: function(value) {
      var val;
      val = this.getField();
      val = val ? val.name : "undefined";
      console.log("DEBUG " + val + ":" + this.type, value);
      return value;
    }
  };
  return Operation;
});

var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('parser',["operation", "q"], factory);
  } else {
    return root.Parser = factory(root.operation, root.Q);
  }
})(this, function(operation, Q) {
  var Parser, StopParsingError;
  Parser = (function() {
    function Parser(config) {
      this.handleConfig(config);
      this.parsingConfig = {};
      this.result = {};
      this.value = function(valName, op, cb) {
        var field, res, toResolve, valResult;
        valResult = this.result[valName];
        if (valResult !== void 0) {
          if (cb && typeof cb === 'function') {
            return cb(valResult);
          } else {
            return valResult;
          }
        } else if (this.preBuildResults[valName]) {
          if (cb && typeof cb === 'function') {
            return Q(this.preBuildResults[valName] || null).then(function(val) {
              return cb(val);
            });
          } else {
            return this.preBuildResults[valName] || null;
          }
        } else if (this.parsingConfig[valName]) {
          field = this.parsingConfig[valName];
          toResolve = field;
          res = Q.fcall((function(_this) {
            return function() {
              return _this.resolveValue(toResolve, op);
            };
          })(this));
          res.then((function(_this) {
            return function(val) {
              _this.result[valName] = val;
              if (cb && typeof cb === 'function') {
                return cb(val);
              }
            };
          })(this), (function(_this) {
            return function(error) {
              if (error.type = "StopParsingError") {
                return _this.stopParsing();
              } else {
                if (cb && typeof cb === 'function') {
                  return cb(false);
                }
              }
            };
          })(this));
          return res;
        } else {
          if (cb && typeof cb === 'function') {
            return cb(null);
          }
        }
      };
      this.setAttr = function(attrName, value) {
        return this[attrName] = value;
      };
      this.getAttr = function(attrName) {
        return this[attrName] || null;
      };
    }

    Parser.prototype.handleConfig = function(config) {
      var parser;
      config = config || document;
      this.config = config;
      this.config.prompt = this.config.prompt || prompt.bind(window);
      this.defaultParsingConfig = false;
      this.defaultValues = config.defaultValues || {};
      this.preBuildResults = config.preBuildResults || {};
      this.debug = config.debug || false;
      if (config instanceof HTMLDocument) {
        return this.doc = config;
      } else if (typeof config === "string") {
        parser = new DOMParser();
        return this.doc = parser.parseFromString(config, "application/xml");
      } else if (typeof config === "object") {
        this.doc = config.document || document;
        this.addOperations(this.config.operations || {});
        return this.addDecorators(this.config.decorators || {});
      }
    };

    Parser.prototype.addOperations = function(operations) {
      var name, _results;
      _results = [];
      for (name in operations) {
        if (!__hasProp.call(operations, name)) continue;
        operation = operations[name];
        _results.push(Operation.prototype.operations[name] = operation);
      }
      return _results;
    };

    Parser.prototype.addDecorators = function(decorators) {
      var decorator, name, _results;
      _results = [];
      for (name in decorators) {
        if (!__hasProp.call(decorators, name)) continue;
        decorator = decorators[name];
        _results.push(Operation.prototype.decorators[name] = decorator);
      }
      return _results;
    };

    Parser.prototype.addFieldDecorators = function(handlers) {
      var handler, name, _results;
      _results = [];
      for (name in handlers) {
        if (!__hasProp.call(handlers, name)) continue;
        handler = handlers[name];
        _results.push(Parser.prototype.handlers[name] = handler);
      }
      return _results;
    };

    return Parser;

  })();
  Parser.prototype.log = function() {
    if (this.debug) {
      return console.log.apply(console, arguments);
    }
  };

  /*
  @param {array} config
  @param {array} config
  ...
  @param {function} cb callback
   */
  Parser.prototype.parse = function() {
    var cb, config, d, toWait, value, _i, _j, _len, _len1, _parse, _ref;
    if (this.config.onParsingStart) {
      this.config.onParsingStart();
    }
    toWait = [];
    d = Q.defer();
    this.result = {};
    this.parsingConfig = {};
    if (arguments.length > 1) {
      if (typeof arguments[arguments.length - 1] === 'function') {
        cb = arguments[arguments.length - 1];
        config = Parser.prototype.mergeConfigs(Array.prototype.slice.call(arguments, 0, arguments.length - 1));
      } else {
        config = Parser.prototype.mergeConfigs(Array.prototype.slice.call(arguments, 0, arguments.length));
      }
    } else if (!arguments.length) {
      d.resolve(new Error("Wrong arguments"));
    } else {
      config = arguments[0];
    }
    for (_i = 0, _len = config.length; _i < _len; _i++) {
      value = config[_i];
      this.parsingConfig[value.name] = value;
    }
    if (this.config.defaultConfig) {
      this.defaultParsingConfig = {};
      _ref = this.config.defaultConfig;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        value = _ref[_j];
        this.defaultParsingConfig[value.name] = value;
      }
    }
    _parse = (function(_this) {
      return function(config) {
        var handleValue, queue, _parseDeferred;
        _parseDeferred = Q.defer();
        handleValue = function(value) {
          var handleDeferred;
          handleDeferred = Q.defer();
          _this.log("= Parser: calculating " + value.name + ". Config:", value);
          Q.fcall(function() {
            return _this.resolveValue(value);
          }).then(function(res) {
            if (!res && _this.defaultParsingConfig[value.name]) {
              return Q.fcall(function() {
                return _this.resolveValue(_this.defaultParsingConfig[value.name]);
              }).then(function(res) {
                if (!res && _this.defaultValues[value.name]) {
                  _this.result[value.name] = _this.defaultValues[value.name];
                } else {
                  _this.result[value.name] = res;
                }
                return handleDeferred.resolve();
              }, function(error) {
                return handleDeferred.resolve();
              });
            } else {
              _this.log("= Parser: calculated " + value.name + ". Result:", res);
              _this.result[value.name] = res;
              return handleDeferred.resolve();
            }
          }, function(error) {
            if (error instanceof StopParsingError) {
              console.log(error.message);
              return handleDeferred.reject(error);
            } else {
              console.log("Error resolveValue", error.stack);
              return handleDeferred.resolve();
            }
          });
          return handleDeferred.promise;
        };
        queue = Q(true);
        queue.then(function() {
          config.forEach(function(value) {
            return queue = queue.then(function() {
              return handleValue(value);
            });
          });
          return queue.then(function() {
            return _parseDeferred.resolve();
          }, function(error) {
            return _parseDeferred.reject(error);
          });
        });
        return _parseDeferred.promise;
      };
    })(this);
    _parse(config).then((function(_this) {
      return function() {
        return _this.afterParse(_this.result).then(function() {
          if (_this.config.onParsingEnd) {
            _this.config.onParsingEnd();
          }
          if (cb && typeof cb === 'function') {
            return cb(_this.result);
          } else {
            return d.resolve(_this.result);
          }
        });
      };
    })(this), (function(_this) {
      return function(error) {
        if (cb && typeof cb === 'function') {
          return cb(error);
        } else {
          return d.reject(error);
        }
      };
    })(this));
    return d.promise;
  };
  Parser.cache = {};
  Parser.clearCache = (function(_this) {
    return function() {
      return Parser.cache = {};
    };
  })(this);

  /*
  @param {object|array} configs
  @returns {object}
   */
  Parser.prototype.mergeConfigs = function(configs) {
    var config, field, res, _i, _j, _len, _len1;
    res = {};
    for (_i = 0, _len = configs.length; _i < _len; _i++) {
      config = configs[_i];
      for (_j = 0, _len1 = config.length; _j < _len1; _j++) {
        field = config[_j];
        if (typeof res[field.name] === "undefined") {
          res[field.name] = field;
        }
      }
    }
    return Object.keys(res).map(function(key) {
      return res[key];
    });
  };

  /*
  @value {object} value linked with operation
  @evalConfig {mixed} config for newly created operation
   */
  Parser.prototype.createOperationForValue = function(value, evalConfig) {
    return new Operation(evalConfig).setField(value).setParser(this);
  };
  Parser.prototype.resolveValue = function(value, operation) {
    var o;
    if (this.config.onFieldParsing) {
      this.config.onFieldParsing(value.name, value);
    }
    if (Parser.cache[value.name]) {
      return Parser.cache[value.name];
    } else if (this.result[value.name]) {
      return this.result[value.name];
    } else if (this.preBuildResults[value.name]) {
      return this.preBuildResults[value.name];
    } else {
      if (operation) {
        if (value.parentFields) {
          value.parentFields.push(operation.getField());
        } else {
          value.parentFields = [operation.getField()];
        }
      }
      o = this.createOperationForValue(value, value.operations || value.value);
      return o.evaluate(value.value).then((function(_this) {
        return function(res) {
          if (value.persist) {
            Parser.cache[value.name] = res;
          }
          return _this.finalizeValue(o.getField(), res);
        };
      })(this));
    }
  };
  Parser.prototype.afterParse = function() {
    var d, field, fieldName, _ref;
    d = Q.defer();
    _ref = this.parsingConfig;
    for (fieldName in _ref) {
      field = _ref[fieldName];
      if (!this.result[field.name] && field.required) {
        if (this.defaultValues[field.name]) {
          this.result[field.name] = this.defaultValues[field.name];
        }
      }
    }
    d.resolve();
    return d.promise;
  };
  Parser.prototype.handlers = {
    postprocessing: function(config, result) {
      if (config.postprocessing) {
        return new Operation(config.postprocessing).evaluate(result);
      }
    },
    required: function(config, result) {
      var promptText;
      if (this.defaultValues[config.name] && !result) {
        return this.defaultValues[config.name];
      } else if (config.required && !result) {
        promptText = config.prompt_text || "Please set value for " + (config.label ? config.label : config.name);
        result = this.config.prompt(promptText);
        return Q.when(result).then((function(_this) {
          return function(userInput) {
            if (userInput === null) {
              return _this.stopParsing();
            } else {
              return userInput;
            }
          };
        })(this));
      } else {
        return result;
      }
    },
    "default": function(config, result) {
      if (!result) {
        if (config["default"]) {
          return result = config["default"];
        } else {
          return result;
        }
      } else {
        return result;
      }
    }
  };
  Parser.prototype.finalizeValue = function(config, result) {
    var found, func, handlerName, toReturn, toWait, _ref;
    toReturn = result;
    found = false;
    toWait = null;
    _ref = Parser.prototype.handlers;
    for (handlerName in _ref) {
      func = _ref[handlerName];
      if (typeof config[handlerName] !== "undefined") {
        (function(_this) {
          return (function(handlerName, func) {
            if (toWait === null) {
              return toWait = Q(func.call(_this, config, result)).then(function(r) {
                return result = r;
              });
            } else {
              return toWait = toWait.then(function(r) {
                return Q(func.call(_this, config, result)).then(function(r) {
                  return result = r;
                });
              });
            }
          });
        })(this)(handlerName, func);
        found = true;
      }
    }
    if (!found) {
      return toReturn;
    } else {
      return toWait.then(function() {
        return result;
      });
    }
  };
  Parser.prototype.stopParsing = function() {
    var error;
    error = new StopParsingError("User canceled parsing");
    error.type = "StopParsingError";
    throw error;
  };
  StopParsingError = (function(_super) {
    __extends(StopParsingError, _super);

    function StopParsingError(message) {
      this.message = message;
      StopParsingError.__super__.constructor.call(this, this.message);
    }

    return StopParsingError;

  })(Error);
  return Parser;
});

