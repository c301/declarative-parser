(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('utils',factory);
  } else {
    return root.utils = factory();
  }
})(this, function() {
  return {
    /*
    Evaluate xpath string
    @param aNode context node
    @param aExpr Xpath expression
    */
    xpathEval: function(aNode, aExpr) {
      var e, found, nsResolver, res, result, xpe;
      //passed only expresion
      if (arguments.length === 1) {
        aExpr = aNode;
        aNode = document;
      }
      xpe = new XPathEvaluator();
      nsResolver = xpe.createNSResolver(aNode.ownerDocument === null ? aNode.documentElement : aNode.ownerDocument.documentElement);
      try {
        result = xpe.evaluate(aExpr, aNode, nsResolver, 0, null);
      } catch (error) {
        e = error;
        console.log(e);
        return false;
      }
      found = [];
      if (result.resultType === 4) {
        while (res = result.iterateNext()) {
          found.push(res);
        }
        if (found.length) {
          return found;
        } else {
          return null;
        }
      } else {
        if (result.resultType === 2) {
          return result.stringValue;
        }
      }
    },
    isEmpty: function(obj) {
      var hasOwnProperty, key;
      hasOwnProperty = Object.prototype.hasOwnProperty;
      if (obj === null) {
        return true;
      }
      if (obj.length && obj.length > 0) {
        return false;
      }
      if (obj.length === 0) {
        return true;
      }
      for (key in obj) {
        if (hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
  };
});

var indexOf = [].indexOf,
  hasProp = {}.hasOwnProperty;

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('operations',["q", "utils"], factory);
  } else {
    return root.operations = factory(root.Q, root.utils);
  }
})(this, function(Q, utils) {
  var operations;
  operations = {};
  //config can be accessed via this.config
  operations.manual = function() {
    if (this.config && typeof this.config.value !== "undefined") {
      return this.config.value;
    } else {
      return Operation.EMPTY_VALUE;
    }
  };
  //we can pass existing value (from previos operation) as argument
  operations.regex = function(value) {
    var applyRegex, toReturn;
    applyRegex = (value) => {
      var modifier, nextRes, reg, res, toReturn;
      toReturn = Operation.EMPTY_VALUE;
      if (value) {
        modifier = "";
        if (typeof this.config.modifier !== 'undefined') {
          modifier = this.config.modifier;
        }
        reg = new RegExp(this.config.regex, modifier);
        if (indexOf.call(modifier, 'g') >= 0) {
          toReturn = [];
          while ((nextRes = reg.exec(value)) !== null) {
            if (nextRes) {
              if (this.config.full) {
                toReturn.push(nextRes);
              } else {
                toReturn.push(nextRes[1]);
              }
            }
          }
        } else {
          res = reg.exec(value);
          if (this.config.full) {
            if (res) {
              toReturn = res;
            } else {
              toReturn = Operation.EMPTY_VALUE;
            }
          } else {
            if (res) {
              toReturn = res[1];
            } else {
              toReturn = Operation.EMPTY_VALUE;
            }
          }
        }
        return toReturn;
      } else {
        return Operation.EMPTY_VALUE;
      }
    };
    if (Array.isArray(value)) {
      return toReturn = value.map(applyRegex);
    } else {
      return applyRegex(value);
    }
  };
  //we have to use this.getDoc() in order to use right document
  operations.xpath = function(value) {
    var xpath;
    xpath = this.config.xpath;
    if (xpath) {
      return this.substitudeAttrAndValues(xpath).then((xpath) => {
        var d;
        console.log('=== xpath', xpath);
        if (this.config.document_url) {
          // console.log("Xpath: document_url detected")
          d = Q.defer();
          this.createOperation(this.config.document_url).evaluate().then((result) => {
            var xhr;
            // console.log("Xpath: document_url %s", result)
            xhr = new XMLHttpRequest();
            xhr.open('GET', result, true);
            xhr.onload = (e) => {
              var doc, parser, txt, xpathResult;
              if (xhr.status === 200) {
                txt = xhr.responseText;
                parser = new DOMParser();
                doc = parser.parseFromString(txt, "text/html");
                return xpathResult = utils.xpathEval(doc, xpath);
              } else {
                return d.resolve(new Error());
              }
            };
            xhr.ontimeout = function(e) {
              return d.resolve(new Error());
            };
            xhr.onerror = function(e) {
              return d.resolve(new Error());
            };
            return xhr.send();
          });
          return d.promise;
        } else {
          if (this.config.doc) {
            d = Q.defer();
            this.createOperation(this.config.doc).evaluate(value).then((doc) => {
              var res;
              res = utils.xpathEval(doc, xpath);
              return d.resolve(res);
            });
            return d.promise;
          } else {
            if (value instanceof HTMLDocument || value instanceof XMLDocument) {
              return utils.xpathEval(value, xpath);
            } else {
              return utils.xpathEval(this.getDoc(), xpath);
            }
          }
        }
      });
    } else {
      return Operation.EMPTY_VALUE;
    }
  };
  operations.wait = function(value) {
    var d;
    d = Q.defer();
    window.setTimeout(function() {
      return d.resolve(value);
    }, this.config.delay);
    return d.promise;
  };
  operations.get_attribute = function(value) {
    var d, getAttr, res;
    d = Q.defer();
    getAttr = function(el, attr) {
      var res;
      res = el[attr];
      if (!res && (el instanceof HTMLElement || el.getAttribute)) {
        return res = el.getAttribute(attr || Operation.EMPTY_VALUE);
      } else {
        return res || Operation.EMPTY_VALUE;
      }
    };
    if (value) {
      res = [];
      this.createOperation(this.config.attribute).evaluate().then(function(attribute) {
        var e, el, j, len;
        try {
          if (!value[attribute] && value.length !== void 0) {
            for (j = 0, len = value.length; j < len; j++) {
              el = value[j];
              if (el) {
                res.push(getAttr(el, attribute));
              }
            }
          } else {
            res = getAttr(value, attribute);
          }
          return d.resolve(res);
        } catch (error) {
          e = error;
          console.log(e);
          return d.resolve(Operation.EMPTY_VALUE);
        }
      });
    } else {
      d.resolve(value);
    }
    return d.promise;
  };
  operations.set_attribute = function(value) {
    var attr, toWait;
    attr = this.config.attribute;
    if (!(value instanceof Array)) {
      value = [value];
    }
    toWait = [];
    value.forEach((el) => {
      var calculateAttr, d, finalAttrs, fn, k, v;
      d = Q.defer();
      finalAttrs = {};
      calculateAttr = [];
      fn = (k, v) => {
        var def;
        def = this.createOperation(v).evaluate(el).then((finalValue) => {
          return finalAttrs[k] = finalValue;
        });
        return calculateAttr.push(def);
      };
      for (k in attr) {
        if (!hasProp.call(attr, k)) continue;
        v = attr[k];
        fn(k, v);
      }
      Q.allSettled(calculateAttr).then(() => {
        for (k in finalAttrs) {
          if (!hasProp.call(finalAttrs, k)) continue;
          v = finalAttrs[k];
          el[k] = v;
        }
        return d.resolve();
      });
      return toWait.push(d.promise);
    });
    return Q.allSettled(toWait);
  };
  // represents "if" statements
  operations.switchOf = function(value) {
    var execPosOrNeg;
    execPosOrNeg = (res) => {
      if (!!res) {
        return this.createOperation(this.config.positive).evaluate(value);
      } else {
        return this.createOperation(this.config.negative).evaluate(value);
      }
    };
    if (this.config.value) {
      return this.createOperation(this.config.value).evaluate(value).then((res) => {
        return this.createOperation(this.config.flag).evaluate(res).then((res) => {
          //          console.log "Flag", res, @config.flag
          return execPosOrNeg(res);
        });
      });
    } else if (this.config.flag) {
      // calculating flag
      return this.createOperation(this.config.flag).evaluate(value).then((res) => {
        //        console.log "Flag", res, @config.flag
        return execPosOrNeg(res);
      });
    } else {
      // check value
      return execPosOrNeg(value);
    }
  };
  //evaluate html template
  operations.html_template = function() {
    var html;
    html = this.config.template;
    return this.substitudeAttrAndValues(html);
  };
  // operations.jsonpath = (value)->
  //   console.log("JSONPath",value, @config.jsonpath);
  //   d = Q.defer()
  //   jsonpath = @config.jsonpath
  //   toWait = []
  //   for fname in jsonpath.match( /\{:(.+?):\}/ig )
  //     do ( fname )=>
  //       el = /\{:(.+?):\}/.exec(fname)[1]
  //       def = Q( @getValue el).then (val)->
  //         console.log el, val
  //         jsonpath = jsonpath.replace fname, val || ''

  //       toWait.push def

  //   Q.allSettled toWait
  //     .then ()=>
  //       res = jsonPath.eval(value, jsonpath) console.log("JSONPath #{jsonpath} : #{res}")
  //       d.resolve res

  //   d.promise
  operations.values_to_map = function(value) {};
  //return HTMLDocument according to current context
  operations.current_document = function() {
    return this.getDoc();
  };
  //returns result of the comparison
  operations.equal = function(value) {
    var res;
    //    console.log "equal", value, @config.value, @config.is_regex
    res = Operation.EMPTY_VALUE;
    if (this.config.is_regex) {
      res = new RegExp(this.config.value, "i").test(value);
    } else {
      res = value === this.config.value;
    }
    return res;
  };
  operations.parsed_val = function() {
    var valueName;
    valueName = this.config.valName || this.config.name;
    return Q(this.getValue(valueName)).then((value) => {
      if (typeof value === 'undefined') {
        console.log(`Warning: ${valueName} not found`);
      }
      return value;
    });
  };
  operations.concatenation = function() {
    var fn, glue, j, len, part, parts, results, toWait;
    parts = this.config.parts;
    glue = this.config.glue || "";
    results = [];
    toWait = Q(true);
    fn = (part) => {
      return toWait = toWait.then((res) => {
        return this.createOperation(part).evaluate().then(function(res) {
          return results.push(res);
        });
      });
    };
    for (j = 0, len = parts.length; j < len; j++) {
      part = parts[j];
      fn(part);
    }
    return toWait.then(() => {
      var result;
      result = results.filter(function(val) {
        if (val) {
          return val;
        }
      });
      return result = result.join(glue);
    });
  };
  operations.collection = function() {
    var d, fn, j, len, part, parts, toWait;
    parts = this.config.parts;
    toWait = [];
    d = Q.defer();
    fn = (part) => {
      return toWait.push(this.createOperation(part).evaluate().then(function(res) {
        return res;
      }));
    };
    for (j = 0, len = parts.length; j < len; j++) {
      part = parts[j];
      fn(part);
    }
    Q.allSettled(toWait).then((res) => {
      var result;
      result = res.map(function(v) {
        return v.value;
      });
      return d.resolve(result.filter(function(val) {
        if (val) {
          return val;
        }
      }));
    });
    return d.promise;
  };
  operations.parseJSON = function(value) {
    var res;
    res = {};
    return res = JSON.parse(value);
  };
  operations.parse_json = function(value) {
    var res;
    res = {};
    return res = JSON.parse(value);
  };
  operations.split = function(value) {
    if (this.config.separator) {
      return value.split(this.config.separator);
    } else {
      return value;
    }
  };
  operations.randomInt = function() {
    var from, getRandomInt, to;
    getRandomInt = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    from = this.config.from || 0;
    to = this.config.to || 100;
    return getRandomInt(from, to);
  };
  operations.badOperation = function() {
    return wrongVar;
  };
  operations.js_eval = function() {
    var d, fn, i, j, js, len, m, promises, res;
    js = this.config.js;
    d = Q.defer();
    m = js.match(/\{:(.+?):\}/ig);
    if (m) {
      promises = [];
      fn = (i) => {
        var el, tmp, val;
        el = /\{:(.+?):\}/.exec(i)[1];
        val = Q(this.getValue(el));
        // console.log "1 js_eval getting", i, val
        tmp = val.then(function(replacer) {
          if (!replacer) {
            replacer = '';
          }
          return js = js.replace(i, replacer);
        });
        
        // console.log "js_eval", i, replacer, js
        return promises.push(tmp);
      };
      for (j = 0, len = m.length; j < len; j++) {
        i = m[j];
        fn(i);
      }
      Q.allSettled(promises).then(() => {
        var res;
        res = eval(js);
        return d.resolve(res);
      });
    } else {
      res = eval(js);
      d.resolve(res);
    }
    return d.promise;
  };
  operations.remove_element = function(value) {
    if (!(value instanceof Array)) {
      value = [value];
    }
    return value.forEach(function(el) {
      if (el && (el instanceof HTMLElement)) {
        return el.parentNode.removeChild(el);
      }
    });
  };
  return operations;
});



;!function(undefined) {

	var ObjectPath = {
		parse: function(str){
			if(typeof str !== 'string'){
				throw new TypeError('ObjectPath.parse must be passed a string');
			}

			var i = 0;
			var parts = [];
			var d, b, q, c;
			while (i < str.length){
				d = str.indexOf('.', i);
				b = str.indexOf('[', i);

				// we've reached the end
				if (d === -1 && b === -1){
					parts.push(str.slice(i, str.length));
					i = str.length;
				}

				// dots
				else if (b === -1 || (d !== -1 && d < b)) {
					parts.push(str.slice(i, d));
					i = d + 1;
				}

				// brackets
				else {
					if (b > i){
						parts.push(str.slice(i, b));
						i = b;
					}
					q = str.slice(b+1, b+2);
					if (q !== '"' && q !=='\'') {
						c = str.indexOf(']', b);
						if (c === -1) c = str.length;
						parts.push(str.slice(i + 1, c));
						i = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;
					} else {
						c = str.indexOf(q+']', b);
						if (c === -1) c = str.length;
						while (str.slice(c - 1, c) === '\\' && b < str.length){
							b++;
							c = str.indexOf(q+']', b);
						}
						parts.push(str.slice(i + 2, c).replace(new RegExp('\\'+q,'g'), q));
						i = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;
					}
				}
			}
			return parts;
		},

		// root === true : auto calculate root; must be dot-notation friendly
		// root String : the string to use as root
		stringify: function(arr, quote){

			if(!Array.isArray(arr))
				arr = [arr.toString()];

			quote = quote === '"' ? '"' : '\'';

			return arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\' + quote) + quote + ']'; }).join('');
		},

		normalize: function(data, quote){
			return ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);
		},

		// Angular
		registerModule: function(angular) {
			angular.module('ObjectPath', []).provider('ObjectPath', function(){
				this.parse = ObjectPath.parse;
				this.stringify = ObjectPath.stringify;
				this.normalize = ObjectPath.normalize;
				this.$get = function(){
					return ObjectPath;
				};
			});
		}
	};

	// AMD
	if (typeof define === 'function' && define.amd) {
		define('objectpath',[],function() {
			return {ObjectPath: ObjectPath};
		});
	}

	// CommonJS
	else if (typeof exports === 'object') {
		exports.ObjectPath = ObjectPath;
	}

	// Browser global
	else {
		window.ObjectPath = ObjectPath;
	}
	
}();
var hasProp = {}.hasOwnProperty;

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('operation',["operations", "q", "utils", "objectpath"], factory);
  } else {
    return root.Operation = factory(root.operations, root.Q, root.utils, {
      ObjectPath: root.ObjectPath
    });
  }
})(this, function(operations, Q, utils, objectpath) {
  var Operation, getPathFromObject, parseObjectPath, substitudeAttrAndValues;
  parseObjectPath = function(pathStr) {
    var parsedPath, toReturn;
    toReturn = {
      base: pathStr,
      path: []
    };
    parsedPath = objectpath.ObjectPath.parse(pathStr);
    toReturn.base = parsedPath[0];
    toReturn.path = parsedPath.splice(1);
    return toReturn;
  };
  getPathFromObject = function(sourceObj, path) {
    var toReturn;
    toReturn = sourceObj;
    path.forEach(function(part) {
      return toReturn = toReturn[part] ? toReturn[part] : Operation.EMPTY_VALUE;
    });
    return toReturn;
  };
  substitudeAttrAndValues = function(operation, originalStr) {
    var attr, el, fn, fname, i, j, len, len1, m, newStr, parsedPath, parser, ref, ref1, toWait;
    newStr = originalStr;
    toWait = Q(true);
    parser = operation.getParser();
    m = newStr.match(/\{:(.+?):\}/ig);
    ref = m || [];
    //get attributes
    for (i = 0, len = ref.length; i < len; i++) {
      fname = ref[i];
      el = /\{:(.+?):\}/.exec(fname)[1];
      if (parser) {
        parsedPath = parseObjectPath(el);
        attr = parser.getAttr(parsedPath.base);
        if (attr !== Operation.EMPTY_VALUE) {
          newStr = newStr.replace(fname, getPathFromObject(attr, parsedPath.path));
        }
      }
    }
    m = newStr.match(/\{:(.+?):\}/ig);
    ref1 = m || [];
    //get values
    fn = (fname) => {
      return toWait = toWait.then(() => {
        el = /\{:(.+?):\}/.exec(fname)[1];
        parsedPath = parseObjectPath(el);
        // console.log "newStr template getting field #{fname}, #{el}"
        return Q(operation.getValue(parsedPath.base)).then((val) => {
          // console.log 'got el', el, fname, val
          return newStr = newStr.replace(fname, getPathFromObject(val, parsedPath.path) || '');
        });
      });
    };
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      fname = ref1[j];
      fn(fname);
    }
    return toWait.then(function() {
      return newStr;
    });
  };
  Operation = class Operation {
    constructor(config) {
      var val;
      this.parser = null;
      this.field = null;
      this.config = config;
      /*
      We have to use this shortcut to create new operation inside existing one, in order to save execution context
      */
      this.createOperation = function(config) {
        return new Operation(config).setParser(this.getParser()).setField(this.getField());
      };
      //default evaluate
      this._evaluate = function(res) {
        return res || Operation.EMPTY_VALUE;
      };
      this.evaluate = function(value, cb) {
        var d, nonEmptyValue;
        d = Q.defer();
        //set callback
        cb = cb || function() {};
        if (typeof cb !== 'function') {
          cb = function() {};
        }
        if (typeof value === 'function' && arguments.length === 1) {
          cb = value;
          value = Operation.EMPTY_VALUE;
        }
        nonEmptyValue = !!value;
        if (value && value.length !== void 0 && value.length === 0) {
          nonEmptyValue = false;
        }
        if (this.config.final && nonEmptyValue) {
          cb(value);
          d.resolve(value);
        } else {
          if (!this._evaluate) {
            Operation.EMPTY_VALUE;
          } else {
            Q(this._evaluate(value)).then((result) => {
              return Q.fcall(() => {
                return this.decorate(result);
              }).then((res) => {
                cb(res);
                return d.resolve(res);
              }, (error) => {
                var val;
                val = this.getField();
                val = val ? val.name : "undefined";
                console.log(`Error during decoration ${val}: ${this.type}`, error.stack);
                cb(result);
                return d.resolve(result);
              });
            }, (error) => {
              var val;
              if (error.type = "StopParsingError") {
                return d.reject(error);
              } else {
                val = this.getField();
                val = val ? val.name : "undefined";
                console.log(`Error in ${val}: ${this.type}`, error.stack);
                cb(value);
                return d.resolve(value);
              }
            });
          }
        }
        return d.promise;
      };
      this.setParser = function(parser1) {
        this.parser = parser1;
        return this;
      };
      this.getParser = function() {
        return this.parser;
      };
      this.setField = function(field) {
        this.field = field;
        return this;
      };
      this.getField = function() {
        return this.field;
      };
      this.getDoc = function() {
        var parser;
        parser = this.getParser();
        if (parser) {
          return parser.doc;
        } else {
          return document;
        }
      };
      this.getValue = (valName, cb) => {
        var dep, i, len, parent, parser, value;
        if (this.getField() && this.getField().parentFields) {
          parent = this.getField().parentFields;
          for (i = 0, len = parent.length; i < len; i++) {
            dep = parent[i];
            if (dep.name === valName) {
              console.log("Warning: Cirsular dependencies while getting %s from %o", valName);
              return false;
            }
          }
        }
        parser = this.getParser();
        // console.log("get field #{valName}", parser)
        if (parser) {
          value = parser.value(valName, this, cb);
          return value;
        } else {
          return Operation.EMPTY_VALUE;
        }
      };
      this.substitudeAttrAndValues = (str) => {
        return substitudeAttrAndValues(this, str);
      };
      this.getType = function(config) {
        var attr, type, typeName, type_mapping;
        type = '';
        type_mapping = {
          "storedName": "stored",
          "xpath": "xpath",
          "regex": "regex",
          "valName": "parsed_val",
          "value": "manual",
          "attribute": "get_attribute",
          "template": "html_template",
          "opName": "pre_built",
          "js": "js_eval",
          "separator": "split"
        };
        if (config && config.type !== void 0) {
          type = config.type;
        } else {
          for (attr in type_mapping) {
            if (!hasProp.call(type_mapping, attr)) continue;
            typeName = type_mapping[attr];
            if (typeof config[attr] !== "undefined") {
              type = typeName;
              break;
            }
          }
        }
        if (!type) {
          for (attr in config) {
            if (!hasProp.call(config, attr)) continue;
            typeName = config[attr];
            if (typeof this.operations[attr] !== "undefined") {
              type = attr;
              break;
            }
          }
        }
        config.type = type;
        return type;
      };
      //if undefined( operations was ommited ), return Operation.EMPTY_VALUE
      if (this.config === void 0) {
        this.config = {
          type: "manual",
          value: Operation.EMPTY_VALUE
        };
      }
      //if array of operations
      if (this.config instanceof Array && this.config.length) {
        this.type = "operationQueue";
        this._evaluate = (value) => {
          return this.evaluateQueue(value);
        };
      } else {
        //in some case return initial value
        if (typeof this.config === "string" || typeof this.config === "number" || this.config === true || this.config === false) {
          this.config = {
            type: "manual",
            value: this.config
          };
        }
        this.type = this.getType(this.config);
        if (!this.type || !this.operations[this.type]) {
          val = this.getField();
          val = val ? val.name : "undefined";
          if (this.type && !this.operations[this.type]) {
            console.log(`Unknown operation type ${val}:${this.type}`, this.config);
          }
        } else {
          this._evaluate = this.operations[this.type];
        }
      }
    }

  };
  //this value should be returned, on soft fail
  Operation.EMPTY_VALUE = '';
  //apply suffix, prefix, etc..
  Operation.prototype.decorate = function(value) {
    var decoratorName, defer, found, func, ref, toReturn, toWait;
    defer = Q.defer();
    toReturn = value;
    //    if !value && !@config.default && value != false
    //      defer.resolve toReturn
    //    else

    //place decorator here in right order
    found = false;
    toWait = null;
    ref = Operation.prototype.decorators;
    // set normalize_space: true by default

    // if @config && @config.type != "manual" && @config.normalize_space != false
    //   @config.normalize_space = true
    for (decoratorName in ref) {
      func = ref[decoratorName];
      if (typeof this.config[decoratorName] !== "undefined") {
        ((decoratorName, func) => {
          if (toWait === null) {
            return toWait = Q(func.call(this, value)).then(function(r) {
              //                console.log "1 #{decoratorName} return #{r} and set value to #{r}"
              return value = r;
            });
          } else {
            return toWait = toWait.then((r) => {
              return Q(func.call(this, value)).then(function(r) {
                //                  console.log "2 #{decoratorName} return #{r} and set value to #{r}"
                return value = r;
              });
            });
          }
        })(decoratorName, func);
        found = true;
      }
    }
    if (!found) {
      defer.resolve(toReturn);
    } else {
      toWait.then(function() {
        return defer.resolve(value);
      });
    }
    return defer.promise;
  };
  Operation.prototype.evaluateQueue = function(value) {
    var i, len, ops, ref, result, singleConf;
    ops = [];
    ref = this.config;
    for (i = 0, len = ref.length; i < len; i++) {
      singleConf = ref[i];
      ops.push(this.createOperation(singleConf));
    }
    result = Q(ops.shift().evaluate(value));
    ops.forEach(function(f) {
      return result = result.then(function(val) {
        // console.log "op type #{f.type} prev val", val, typeof val
        return f.evaluate(val);
      });
    });
    return result;
  };
  Operation.prototype.operations = operations;
  Operation.prototype.parseObjectPath = parseObjectPath;
  Operation.prototype.decorators = {
    post_processing: function(value) {
      return this.decorators.postProcessing.bind(this)(value);
    },
    postProcessing: function(value) {
      var operationConfig;
      operationConfig = this.config.postProcessing || this.config.post_processing || this.config.postprocessing;
      if (operationConfig) {
        return this.createOperation(operationConfig).evaluate(value);
      }
    },
    postprocessing: function(value) {
      return this.decorators.postProcessing.bind(this)(value);
    },
    normalize_space: function(value) {
      var i, len, results, val;
      if (this.config.normalize_space) {
        if (value instanceof Array) {
          results = [];
          for (i = 0, len = value.length; i < len; i++) {
            val = value[i];
            results.push(val = Operation.prototype.decorators.normalize_space.bind(this)(val));
          }
          return results;
        } else {
          if (value === void 0 || typeof value !== 'string') {
            return value;
          } else {
            value = value.trim();
            value = value.replace(/[ \t]{2,}/g, ' ');
            value = value.replace(/^\s*$[\n\r]{1,}/gm, "\n");
            return value;
          }
        }
      } else {
        return value;
      }
    },
    glue: function(value) {
      if (value instanceof Array) {
        return value.filter(function(val) {
          if (val) {
            return val;
          }
        }).join(this.config.glue);
      } else {
        return value;
      }
    },
    suffix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.suffix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(value + res);
          }
          if (value instanceof Array) {
            newvalue = value.map((el) => {
              if (el) {
                return el + res;
              } else {
                return el;
              }
            });
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    preffix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.preffix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(res + value);
          }
          if (value instanceof Array) {
            newvalue = value.map((el) => {
              if (el) {
                return res + el;
              } else {
                return el;
              }
            });
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    prefix: function(value) {
      var d;
      d = Q.defer();
      if (value) {
        this.createOperation(this.config.prefix).evaluate().then(function(res) {
          var newvalue;
          if (typeof value === 'string') {
            d.resolve(res + value);
          }
          if (value instanceof Array) {
            newvalue = value.map((el) => {
              if (el) {
                return res + el;
              } else {
                return el;
              }
            });
            return d.resolve(newvalue);
          }
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    num_in_array: function(value) {
      if (value instanceof Array) {
        return value[this.config.num_in_array];
      } else {
        return value;
      }
    },
    default: function(value) {
      var d;
      d = Q.defer();
      if (!value) {
        this.createOperation(this.config.default).evaluate().then(function(res) {
          return d.resolve(res);
        });
      } else {
        d.resolve(value);
      }
      return d.promise;
    },
    debug: function(value) {
      var val;
      val = this.getField();
      val = val ? val.name : "undefined";
      console.log(`DEBUG ${val}:${this.type}`, value);
      return value;
    }
  };
  return Operation;
});

var hasProp = {}.hasOwnProperty;

(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    return define('parser',["operation", "q"], factory);
  } else {
    return root.Parser = factory(root.operation, root.Q);
  }
})(this, function(operation, Q) {
  var Parser, StopParsingError;
  Parser = class Parser {
    constructor(config) {
      this.handleConfig(config);
      this.parsingConfig = {};
      this.afterParseRule = config ? config.afterParse : false;
      
      //reset result
      this.result = {};
      //value getter
      this.value = function(valName, op, cb) {
        var field, res, toResolve, valResult;
        valResult = this.result[valName];
        // console.log 'valResult for ', valName, valResult
        if (valResult !== void 0) {
          // value already parsed
          // console.log "parser.value return", valResult
          if (cb && typeof cb === 'function') {
            return cb(valResult);
          } else {
            return valResult;
          }
        } else if (this.preBuildResults[valName] || this.preBuildResults[valName] === false) {
          // return value from pre built results, eg results of prev parsing
          // console.log "parser.value return prebuilresult", @preBuildResults[valName]
          if (cb && typeof cb === 'function') {
            return Q(this.preBuildResults[valName] || Operation.EMPTY_VALUE).then(function(val) {
              return cb(val);
            });
          } else {
            return this.preBuildResults[valName] || Operation.EMPTY_VALUE;
          }
        } else if (this.parsingConfig[valName]) {
          // calculate value with config
          // console.log "Parser.value found", @parsingConfig[valName]
          field = this.parsingConfig[valName];
          toResolve = field;
          res = Q.fcall(() => {
            return this.resolveValue(toResolve, op);
          });
          res.then((val) => {
            // if( toResolve.persist )
            this.result[valName] = val;
            if (cb && typeof cb === 'function') {
              return cb(val);
            }
          }, (error) => {
            if (error.type = "StopParsingError") {
              return this.stopParsing();
            } else {
              if (cb && typeof cb === 'function') {
                return cb(false);
              }
            }
          });
          return res;
        } else {
          if (cb && typeof cb === 'function') {
            return cb(Operation.EMPTY_VALUE);
          } else {
            return Operation.EMPTY_VALUE;
          }
        }
      };
      //        val = Operation.EMPTY_VALUE
      //        if !@result[ valName ]
      //          search()
      //        else
      //          val = @result[ valName ]

      this.setAttr = function(attrName, value) {
        return this[attrName] = value;
      };
      this.getAttr = function(attrName) {
        if (this[attrName] === void 0 || this[attrName] === null || this[attrName] === false) {
          return Operation.EMPTY_VALUE;
        } else {
          return this[attrName];
        }
      };
    }

    //set configuration and default values
    handleConfig(config) {
      var parser;
      //nothing passed
      config = config || document;
      if (typeof config === "string") {
        this.config = {};
      } else {
        this.config = config;
      }
      this.config.prompt = this.config.prompt || prompt.bind(window);
      this.defaultParsingConfig = false;
      this.defaultValues = config.defaultValues || {};
      this.preBuildResults = config.preBuildResults || {};
      this.debug = config.debug || false;
      
      //passed html doc
      if (config instanceof HTMLDocument) {
        return this.doc = config;
      //html string passed
      } else if (typeof config === "string") {
        parser = new DOMParser();
        return this.doc = parser.parseFromString(config, "application/xml");
      //config is object with settings
      } else if (typeof config === "object") {
        this.doc = config.document || document;
        this.addOperations(this.config.operations || {});
        return this.addDecorators(this.config.decorators || {});
      }
    }

    addOperations(operations) {
      var name, results;
      results = [];
      for (name in operations) {
        if (!hasProp.call(operations, name)) continue;
        operation = operations[name];
        results.push(Operation.prototype.operations[name] = operation);
      }
      return results;
    }

    addDecorators(decorators) {
      var decorator, name, results;
      results = [];
      for (name in decorators) {
        if (!hasProp.call(decorators, name)) continue;
        decorator = decorators[name];
        results.push(Operation.prototype.decorators[name] = decorator);
      }
      return results;
    }

    addFieldDecorators(handlers) {
      var handler, name, results;
      results = [];
      for (name in handlers) {
        if (!hasProp.call(handlers, name)) continue;
        handler = handlers[name];
        results.push(Parser.prototype.handlers[name] = handler);
      }
      return results;
    }

  };
  Parser.prototype.log = function() {
    if (this.debug) {
      return console.log.apply(console, arguments);
    }
  };
  /*
  @param {array} config
  @param {array} config
  ...
  @param {function} cb callback
  */
  Parser.prototype.parse = function() {
    var _parse, cb, config, d, i, j, len, len1, ref, toWait, value;
    if (this.config.onParsingStart) {
      this.config.onParsingStart();
    }
    // console.log "Parser.parse"
    toWait = [];
    d = Q.defer();
    //clean this.result before next parse
    this.result = {};
    this.parsingConfig = {};
    this.configs = [];
    if (arguments.length > 1) {
      if (typeof arguments[arguments.length - 1] === 'function') {
        cb = arguments[arguments.length - 1];
        this.configs = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
      } else {
        this.configs = Array.prototype.slice.call(arguments, 0, arguments.length);
      }
      config = Parser.prototype.mergeConfigs(this.configs);
    } else if (!arguments.length) {
      d.resolve(new Error("Wrong arguments"));
    } else {
      config = arguments[0];
      this.configs = [config];
    }
    for (i = 0, len = config.length; i < len; i++) {
      value = config[i];
      this.parsingConfig[value.name] = value;
    }
    if (this.config.defaultConfig) {
      this.defaultParsingConfig = {};
      ref = this.config.defaultConfig;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        value = ref[j];
        this.defaultParsingConfig[value.name] = value;
      }
    }
    _parse = (config) => {
      var _parseDeferred, handleValue, queue;
      _parseDeferred = Q.defer();
      handleValue = (value) => {
        var handleDeferred;
        if (this.debug) {
          value.debug = this.debug;
        }
        handleDeferred = Q.defer();
        this.log(`= Parser: calculating ${value.name}. Config:`, value);
        Q.fcall(() => {
          return this.resolveValue(value);
        }).then((res) => {
          if (!res && this.defaultParsingConfig[value.name]) {
            // console.log "Calculating in def config #{value.name}", @defaultParsingConfig[ value.name ]
            return Q.fcall(() => {
              return this.resolveValue(this.defaultParsingConfig[value.name]);
            }).then((res) => {
              if (!res && this.defaultValues[value.name]) {
                this.result[value.name] = this.defaultValues[value.name];
              } else {
                this.result[value.name] = res;
              }
              return handleDeferred.resolve();
            }, (error) => {
              // console.log "Error resolveValue in default config", error.stack
              if (error instanceof StopParsingError) {
                console.log(error.message);
                return handleDeferred.reject(error);
              } else {
                console.log("Error resolveValue", error.stack);
                return handleDeferred.resolve();
              }
            });
          } else {
            this.log(`= Parser: calculated ${value.name}. Result:`, res);
            this.result[value.name] = res;
            return handleDeferred.resolve();
          }
        }, (error) => {
          if (error instanceof StopParsingError) {
            console.log(error.message);
            return handleDeferred.reject(error);
          } else {
            console.log("Error resolveValue", error.stack);
            return handleDeferred.resolve();
          }
        });
        return handleDeferred.promise;
      };
      // console.log config
      queue = Q(true);
      queue.then(() => {
        config.forEach((value) => {
          queue = queue.then(() => {
            return handleValue(value);
          });
          return queue = queue.then(() => {
            if (this.config.parseHooks && this.config.parseHooks[value.name] && this.config.parseHooks[value.name].after) {
              return Q(this.config.parseHooks[value.name].after(this.result[value.name])).then((res) => {
                return this.result[value.name] = res;
              });
            }
          });
        });
        return queue.then(function() {
          return _parseDeferred.resolve();
        }, function(error) {
          return _parseDeferred.reject(error);
        });
      });
      return _parseDeferred.promise;
    };
    _parse(config).then(() => {
      return this.afterParse(this.result).then(() => {
        if (this.config.onParsingEnd) {
          this.config.onParsingEnd();
        }
        if (cb && typeof cb === 'function') {
          return cb(this.result);
        } else {
          return d.resolve(this.result);
        }
      });
    }, (error) => {
      if (cb && typeof cb === 'function') {
        return cb(error);
      } else {
        return d.reject(error);
      }
    });
    return d.promise;
  };
  //set initial empty cache
  Parser.cache = {};
  //set empty cache
  Parser.clearCache = () => {
    return Parser.cache = {};
  };
  /*
  @param {object|array} configs
  @returns {object}
  */
  Parser.prototype.mergeConfigs = function(configs) {
    var config, field, i, j, len, len1, res;
    res = {};
    for (i = 0, len = configs.length; i < len; i++) {
      config = configs[i];
      for (j = 0, len1 = config.length; j < len1; j++) {
        field = config[j];
        if (typeof res[field.name] === "undefined") {
          res[field.name] = field;
        }
      }
    }
    return Object.keys(res).map(function(key) {
      return res[key];
    });
  };
  /*
  @value {object} value linked with operation
  @evalConfig {mixed} config for newly created operation
  */
  Parser.prototype.createOperationForValue = function(value, evalConfig) {
    return new Operation(evalConfig).setField(value).setParser(this);
  };
  Parser.prototype.resolveValue = function(value, operation) {
    var o, ops;
    // console.log "====  prebuildresult exist for #{value.name}",  @preBuildResults[value.name]
    if (this.config.onFieldParsing) {
      this.config.onFieldParsing(value.name, value);
    }
    if (Parser.cache[value.name]) {
      return Parser.cache[value.name];
    } else if (this.result[value.name]) {
      return this.result[value.name];
    } else if (this.preBuildResults[value.name] || this.preBuildResults[value.name] === false) {
      return this.preBuildResults[value.name];
    } else {
      if (operation) {
        // console.log "Set parent field for #{value.name}", operation.getField().name
        if (value.parentFields) {
          value.parentFields.push(operation.getField());
        } else {
          value.parentFields = [operation.getField()];
        }
      }
      ops = value.operations;
      if (this.afterParseRule && this.afterParseRule[value.name] && ops) {
        ops = ops.concat(this.afterParseRule[value.name] || []);
      }
      o = this.createOperationForValue(value, ops || value.value);
      return o.evaluate(value.value).then((res) => {
        if (value.persist) {
          Parser.cache[value.name] = res;
        }
        return this.finalizeValue(o.getField(), res);
      });
    }
  };
  Parser.prototype.afterParse = function() {
    var d, field, fieldName, ref;
    d = Q.defer();
    ref = this.parsingConfig;
    for (fieldName in ref) {
      field = ref[fieldName];
      if (!this.result[field.name] && field.required) {
        if (this.defaultValues[field.name]) {
          this.result[field.name] = this.defaultValues[field.name];
        }
      }
    }
    d.resolve();
    return d.promise;
  };
  Parser.prototype.handlers = {
    postprocessing: function(config, result) {
      if (config.postprocessing) {
        return new Operation(config.postprocessing).evaluate(result);
      }
    },
    required: function(config, result) {
      var promptText;
      if (this.defaultValues[config.name] && !result) {
        return this.defaultValues[config.name];
      } else if (config.required && !result) {
        promptText = config.prompt_text || "Please provide a " + (config.label ? config.label : config.name);
        result = this.config.prompt(promptText, config);
        return Q.when(result).then((userInput) => {
          if (userInput === null) {
            return this.stopParsing();
          } else {
            return userInput;
          }
        });
      } else {
        return result;
      }
    },
    default: function(config, result) {
      if (!result) {
        if (config.default) {
          return result = config.default;
        } else {
          return result;
        }
      } else {
        return result;
      }
    }
  };
  // site_specific_config: ( config, result )->
  //   d = Q.defer()
  //   if !@result['site_specific_results']
  //     @result['site_specific_results'] = {}

  //   for siteName, value of config['site_specific_config']
  //     if !@result['site_specific_results'][siteName]
  //       @result['site_specific_results'][siteName] = {}
  //     op = @createOperationForValue( config, value )
  //     op.evaluate (val)=>
  //       @result['site_specific_results'][siteName][config.name] = val
  //       d.resolve result

  //     #return initial result
  //   d.promise
  Parser.prototype.finalizeValue = function(config, result) {
    var found, func, handlerName, ref, toReturn, toWait;
    toReturn = result;
    //place decorator here in right order
    found = false;
    toWait = null;
    ref = Parser.prototype.handlers;
    for (handlerName in ref) {
      func = ref[handlerName];
      if (typeof config[handlerName] !== "undefined") {
        ((handlerName, func) => {
          if (toWait === null) {
            return toWait = Q(func.call(this, config, result)).then((r) => {
              //                console.log "1 #{decoratorName} return #{r} and set value to #{r}"
              return result = r;
            });
          } else {
            return toWait = toWait.then((r) => {
              return Q(func.call(this, config, result)).then(function(r) {
                //                  console.log "2 #{decoratorName} return #{r} and set value to #{r}"
                return result = r;
              });
            });
          }
        })(handlerName, func);
        found = true;
      }
    }
    if (!found) {
      return toReturn;
    } else {
      return toWait.then(function() {
        return result;
      });
    }
  };
  Parser.prototype.stopParsing = function() {
    var error;
    error = new StopParsingError("User canceled parsing");
    error.type = "StopParsingError";
    throw error;
  };
  StopParsingError = class StopParsingError extends Error {
    constructor(message) {
      super();
      this.message = message;
    }

  };
  return Parser;
});

//define ["operation", "q"], ( Operation, Q )->
;
